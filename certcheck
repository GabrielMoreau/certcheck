#!/bin/bash
#
# 2023/07/28 Gabriel Moreau <Gabriel.Moreau@univ-grenoble-alpes.fr>

export PATH=/bin:/sbin:/usr/bin:/usr/sbin
export LANG=C

export VERSION=0.4.14

################################################################

function usage() {
   cat <<END_USAGE
certcheck - check certificate chain or self-signed

 certcheck check [--base|-b certbase] [--pub|-p certbase.pub.pem] [--key|-k certbase.key.pem] [--chain|-c certbase.chain.pem]
 certcheck text  [--base|-b certbase] [--pub|-p certbase.pub.pem]
 certcheck txt   [--base|-b certbase] [--pub|-p certbase.pub.pem]
 certcheck info  [--base|-b certbase] [--pub|-p certbase.pub.pem]
 certcheck version
 certcheck help

txt and info subcommand are just alias for text.
END_USAGE
   }

################################################################

function say_warning() {
   local exit_code=$1
   local message=$2

   echo "Warning: ${message}" >&2
   exit "${exit_code}"
   }

################################################################

[ -z "$(pidof openssl)" ] || say_warning 1 "openssl running, consider: killall openssl"

################################################################

PID_SSL=
function call_server_kick() {
   [ -n "${PID_SSL}" ] && kill "${PID_SSL}" && sleep .2
   PID_SSL=
}

################################################################

trap 'call_server_kick' 0

################################################################

function call_server_launch() {
   call_server_kick
   PID_SSL=
   openssl s_server -key "${CERT_KEY}" -cert "${CERT_CRT}" "$@" -www > /dev/null &
   PID_SSL=$!
   sleep .5    # give it time to startup
}

################################################################

function check_client_chained() {
   while read -r line
   do
      case "$line" in
         'Verify return code: 0 (ok)')
            return 0
            ;;
         'Verify return code: '*)
            return 1
            ;;
      esac
   done < <(echo | openssl s_client -verify 8 -CApath /etc/ssl/certs/)
   say_warning 2 "something failed, verification output not found!"
}

################################################################

function check_client_selfsigned() {
   echo | openssl s_client -verify 8 -CApath /etc/ssl/certs/ 2>&1 | grep -q 'Verification error: self-signed certificate' && return 0
   say_warning 3 "something failed, verification output not found!"
}

################################################################

function check_cert_ischained() {
   local public_cert=$1
   
   # return 0: chain certificate, 1: self-signed certificate
   same=$(openssl x509 -noout -text -in "${public_cert}" \
      | grep -E '[[:space:]](Subject|Issuer):[[:space:]]' \
      | sed -e 's/^[[:space:]]*Subject//; s/^[[:space:]]*Issuer//;' \
      | sort \
      | uniq -c \
      | awk '{print $1}' \
      | head -1)
   return $((same - 1))
}

################################################################

function check_cert_isselfsigned() {
   local public_cert=$1
   
   # return 0: self-signed certificate, 1: chain certificate
   openssl verify -CAfile "${public_cert}" "${public_cert}" > /dev/null 2>&1
   return $?
}

################################################################

function call_configfiles() {
   local CERT_BASE=$1

   if [ -z "${CERT_BASE}" ]
   then
      [ "${CERT_BND}" = 'inside' ] && CERT_BND="${CERT_CRT}"
      return
   fi

   [ -s "${CERT_CRT}" ] || CERT_CRT="${CERT_BASE}.crt"
   [ -s "${CERT_CRT}" ] || CERT_CRT="${CERT_BASE}"
   [ -s "${CERT_CRT}" ] || CERT_CRT="${CERT_BASE}.cer"
   [ -s "${CERT_CRT}" ] || CERT_CRT="${CERT_BASE}.pub.pem"

   [ -s "${CERT_KEY}" ] || CERT_KEY="${CERT_BASE}.key"
   [ -s "${CERT_KEY}" ] || CERT_KEY="${CERT_BASE}.keystore"
   [ -s "${CERT_KEY}" ] || CERT_KEY="${CERT_BASE}.key.pem"

   [ "${CERT_BND}" = 'inside' ] && CERT_BND="${CERT_CRT}"
   [ -s "${CERT_BND}" ] || CERT_BND="${CERT_BASE}.bundle"
   [ -s "${CERT_BND}" ] || CERT_BND="${CERT_BASE}.ca-bundle"
   [ -s "${CERT_BND}" ] || CERT_BND="${CERT_BASE}.chain.pem"
}

################################################################
################################################################

# command line
action=$1; shift
OPT_SHORT=vb:p:k:c:
OPT_LONG=verbose,base:,pub:,key:,chain:
OPT_PARSED=$(getopt --options $OPT_SHORT --longoptions $OPT_LONG --name "$0" -- "$@")
eval set -- "${OPT_PARSED}"

# global var
export VERBOSE=''
export CERT_BASE=''
export CERT_CRT=''
export CERT_KEY=''
export CERT_BND=''

# get options
while true
do
  case "$1" in
    -v|--verbose)
      VERBOSE='yes'
      shift
      ;;
    -b|--base)
      if [ -n "$2" ]
      then
        CERT_BASE=$2
        shift 2
      else
        usage
        exit 11
      fi
      ;;
    -p|--pub)
      if [ -n "$2" ]
      then
        CERT_CRT=$2
        shift 2
      else
        usage
        exit 12
      fi
      ;;
    -k|--key)
      if [ -n "$2" ]
      then
        CERT_KEY=$2
        shift 2
      else
        usage
        exit 13
      fi
      ;;
    -c|--chain)
      if [ -n "$2" ]
      then
        CERT_BND=$2
        shift 2
      else
        usage
        exit 14
      fi
      ;;
    --)
      shift
      break
      ;;
  esac
done
shift $((OPTIND-1))

# default value without option
if [ -z "${CERT_BASE}" ] || [ -z "${CERT_CRT}" ]
then
  CERT_BASE="${1}"
fi

call_configfiles "${CERT_BASE}"

# actions
case "${action}" in
   check)
      [ -s "${CERT_KEY}" ] || say_warning 4 "missing public key certificate ${CERT_KEY}"
      [ -s "${CERT_CRT}" ] || say_warning 5 "missing private key certificate ${CERT_CRT}"
      if check_cert_ischained "${CERT_CRT}"
      then
         [ -s "${CERT_BND}" ] || say_warning 6 "missing chain certificate ${CERT_BND}"
      fi

      call_server_launch
      if check_cert_ischained "${CERT_CRT}"
      then
        check_client_chained && echo "Error: CA-Bundle is not needed!"
        call_server_launch -CAfile "${CERT_BND}"
        check_client_chained
      else
        check_client_selfsigned || echo "Error: not self-signed certificate!"
      fi
      ret=$?
      call_server_kick

      echo
      case "${ret}" in
         0)
            echo "Ok: everything is good"
            echo "ApacheConf: SSLCertificateKeyFile ${CERT_KEY}"
            echo "ApacheConf: SSLCertificateFile    ${CERT_CRT}"
            check_cert_ischained "${CERT_CRT}" && echo "ApacheConf: SSLCACertificateFile  ${CERT_BND}"
            echo "NGinxConf:  ssl_certificate       ${CERT_CRT};"
            echo "NGinxConf:  ssl_certificate_key   ${CERT_KEY};"
            check_cert_ischained "${CERT_CRT}" && echo "NGinxConf:  # cat ${CERT_BND} >> ${CERT_CRT}"
            ;;
         *)
            echo "Error: something is wrong, verification failed! ($ret)"
            ;;
      esac

      exit "${ret}"
      ;;

   text|txt|info)
      [ -s "${CERT_CRT}" ] || say_warning 7 "missing ${CERT_CRT}"
      if grep -q -- '-----BEGIN PRIVATE KEY-----' "${CERT_CRT}"
      then
         # Cert could have the public and private part in the same file
         grep -q -- '-----BEGIN CERTIFICATE-----' "${CERT_CRT}" || say_warning 8 'give the public and not the private key!'
      fi
      grep -q -- '-----BEGIN CERTIFICATE-----' "${CERT_CRT}" || say_warning 9 "your key isn't in PEM format!"
      if check_cert_isselfsigned "${CERT_CRT}"
      then
         echo "Design: self-signed certificate"
      else
         echo "Design: chained certificate"
      fi
      openssl x509 -noout -text -in "${CERT_CRT}" \
         | grep -E '(Subject|Not Before|Not After[[:space:]]|DNS|Issuer):' \
         | sed -e 's/^\s*//g;' \
         | sort -r
      ;;

   version)
      echo "Version: ${VERSION}"
      ;;

   help|*)
      usage
      ;;
esac

exit 0
